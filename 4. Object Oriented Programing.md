# 4.Object Oriented Programming



# 4.1 Introduction

> OOP



## Coupling and Cohesion

They are two important software design quality measurements



**Cohesion** measures the amout of "relateness" that a module or unit of code contains. Ideally, there should be a "high degree" of cohesion, i.e., everything in the unit is very closely related and serves a single purpose.

The more unrelated purposes a unit serves, the more often it may have to change when maintaining the code.



**Coupling** measures the amout of dependncy betwen units/modules. The more dependency between modules, the more often a change in one will cause a change in another. Ideally, therefore, we want the amount of coupling between modules to be low.



Hence, we want to **maximize cohesion**, and **minimize coupling**.



## Procedural vs Object-Oriented Programming

The style of programming so far in C/C++ is called **procedural programming**. The code is organized in*procedures* that implement the logic of the program (in C/C++ are *functions*) and variables that hold the data. Each variable can hold a single piece of data (e.g., a number, text, data, etc.) or be a structure (a `struct`) that holds complex data with subparts (fields). The variables are passed to the procedures (functions) via parameters or are global variables.



In **object-oriented programming** (OOP), the programs are implemented using objects. **Objects** are units of code that contain data and the procedures that implement the logic that operates over the data. Thus, objects are *self-contained units of data and code*. 

In OOP, the data contained within an object are called **attributes** or **member fields**. The procedures of an object are called **methods**, **operations**, or **member functions**.



To create objects, we must first define classes. **Classes** are blueprints or type specifications that describe the contents of an object. It is similar to how in C, you had to first define a struct type with fields, and only after that, you can create an *instance* of the struct (at which point memory is allocated to store the data fields of the struct).

In OOP, we first need to define a class, which describes the attributes and methods that each object of that type can have. Only after that, we can create objects, which are instances of a class (at which point memory is allocated to store the attributes of the object)

A program that can be written in procedural style can also be written in the OOP style. However, as programs grow in size, it is generally easier to maintain high cohesion and low coupling (characteristics of well-designed code) using OOP. This is because when they are designed correctly, classes/objects naturally have high cohesion (as they combine the data and logic related to that data into a single unit) and help decrease the coupling between modules (use a class based on its interface without knowing its exact implementation)





## Classes

We can put *functions* inside of a *structure*. This lets us keep related data and functions (now called **operations** or **methods** or **member functios**) in the same data structure, which is called a **class**.

An **instance** of a class is called an **object**.

In general, we want to try and avoid giving the client/user too much information about our class and its functionality, which is one of the reasons we only give function signature in header file.

```cpp
// student.h
#ifndef _STUDENT_H_
#define _STUDENT_H_

struct Student {
    int assns, mt, final;
    float grade();
};
#endif

// student.cc
#include "student.h"

float Student::grade() {
    return assns * 0.4 + mt * 0.2 + final * 0.4;
}
// :: is the scope resolution operator to specify that the grade function is a method of the Student class.

// main.cc (client code)
#include "student.h"
#include <iostream>

int main() {
    Student s{60, 70, 80};	// initializes s to the initialization list, s is an object here (an instance of the Student class)
    std::cout << s.grade() << std::endl;
}
```

In object-oriented terminology, a **class** is a user-defined type (so essentially a structure) that can potentially contain functions. Student above is a class. (Note that C++ actually has a separate `class` keyword)
(Here, even Student is defined as a struct, we still call it a class)

An **object** is an instance of a class. (s above is an object)
The functions inside of a class are called **member functions** or * methods**.


`::` is called the **scopt resolution operator**. `C::f` means f in the context of scope C (which could be a class). ``::` is like `.`, where the LHS is class (or a namespace), rather than an object.

BUT, inside the function grade, when I wrote `assns, mt, and final`, what are those variables? Since the fields of a class don't exists until it is instantiated.

Well, they refer to the fields of the object that the method was called on, for example:

```cpp
Student Mahmoud{...};
Mahmoud.grade(); // this function is called on assns, mt, and final, referring to Mahmoud's assns/mt/final variables
```



**All** class methods have a hidden, extra frist parameter called **this**, that is a pointer of the clas type. The parameter `this` is always set to contain the address of the object upon which the method is being invoked. When you access a class field within a class method, it automatically uses `this`. So the implementation of grade() really is:

```cpp
float Student::grade() {
    return this->assns * 0.4 + mt * 0.2 + final * 0.4;
}
```

`this` is a pointer to the object on which the method is called.

```cpp
Mahmoud.grade()l; // this = &Mahmoud
```

Warning: Only use `this` when it is absolutely necessary. Sometimes if you have variables with the same name as your member variables, you should use `this`.



## Initializing Objects

example of an **initialization list** to copy the data values into the object's data fields:
```cpp
Student Mahmoud{60, 70, 80}; // OK, but limited.
// This is initializing directly the fields and assign the values, we have no control what the numbers will be put in there (e.g. -200?)
```
However, we have no way of guaranteeing that any Student object is actually initialized.



**Better solution**: include a method whose job is to *initialize objects*, such methods are called **constructors**.

C++ has a special type of method, called a **constructor** that is used to guaranteed that an object is always initiliazed up creation, and all of the grades were in the correct value range.

The general format of the constructor (abbreviated to `ctor`) is:

```cpp
Name-of-Class-Tyoe ( parameter-list ) {
    // necessary code
}
```

Notes:

- there is no return type, since you're building the actual object, the constructor does not return the object it builds
- the method name is the type name
- the parameter list may be empty
- constructors can be overloaded!
- the method body may be empty, but must be present



Example: implementation of the Student class

## 

```cpp
#ifndef STUDENT_H
#define STUDENT_H

struct Student {
    int assns, mt, final;
    float grade();
    // now include the constructor
    Student(int assns, int mt, int final);
};
#endif


// student.cc
#include "student.h"

float Student::grade() {
    return assns * 0.4 + mt * 0.2 + final * 0.4;
}

int capGrade(int grade) {
    if (grade < 0) return 0;
    if (grade > 100) return 100;
    return grade;
}  

// constructors DON'T have return types, they are just building the objects you ask to initialize

// we do need to specify that this is a Student constructor
Student::Student(int assns, int mt, int final) {
    cout << "Making a studen object" << endl;   // getting printed when we construct an object
    // we can add checks!
    this->assns = capGrade(assns);
    this->mt = capGrade(mt);
    this->final = capGrade(final);
} 

// notice that we use "this->" since our parameter names are the same as our data field names.
// if we don't use "this->", the compiler assumes that I want to use the local parameters, and will assign them to themselves.
// This leaves our data fields uninitialized (or at least, not initialized with the values I want)

// main.cc
#include "student.h"
#include <iostream>
using namespace std;

int main() {
    Student s{60, 70, 80};
}
```



We can also initialize objects using the assignment operator, operator=:

```cpp
Student s = Student{60, 70, 80};
int x = 5;
```

In some circumstances, `( )` can be used to initialize variables, especially when invoking constructors.

```cpp
Student s( 60, 80, 70 );
int x( 5 );
string s( "hello" );
```

However, C++ now has **uniform initialization syntax** using `{}`, which is meant to be used in nealry all initialization situations.

```cpp
Student s{ 60, 70, 80 };
int x{ 5 };
string s{ "hello" };
Node *ptr = new Node{ 10, nullptr };
```

If you want to initialize a heap allocated object: (heap allocation)

```cpp
Student *p = new Student{60, 70, 80};
Student *p{new Student{60, 70, 80}};
// both work the same! but the first one is preferred
```



We can overload our constructors, so it is possible to use default parameters on our constructors (these only go on in the interface, not on the implementation)

```cpp
struct Student {
    int assns, mt, final;
    Student(int assns = 0, int mt = 0, int final = 0);
    float grade();
};
```

and our implementation doesn't need to change!



**Advantages** to having constructors:

1. we can maintain invariants on the values of our fields when our objects are initialized.
2. we can have default parameters (this needs to be in the header file)
3. allows overloading
4. allows sanity checks
5. allows code other than simple field initialization





# 4.2 Special Class Members





## Default Constructors

```cpp
struct Student {
    ...
    Student(int assnc = 0, int mt = 0, int final = 0);
    ...
};

Student::Student(int assns, int mt, int final) {
    this->assns = assns;
    this->mt = mt;
    this->final = final;
}

Student A{70, 80}; // A has annas 70 mt 80, final 0
Studetnt newKid; // object be constructed with no arguments -> 0, 0, 0
```
:arrow_heading_up: This invokes the zero-parameter ctor which is called the **default constructor**
Default constructor just means the *ctor with zero parameters*.

```cpp
Vec v; // default ctor (which does nothing)
```



**Note:** every class has a compiler provided default constructor, which just default constructs any fields which are objects. (object is an instantiation of a class)
BUT the built-in default ctor goes away if you provide any other constructor.

```cpp
struct Vec {
    int x, y;
    Vec (int x, int y) {
        this->x = x;
        this->y  y;
    }
};
Vec v{1, 2}; // ok
Vec w; // error!! will not compile
// We provided our ctor, so the default ctor disappears.
// If you remove the constructor, then w will become valid and v1 invalid
// To make both valid, you will need to write two constructors
```



### Initializing Constants and References (MIL)

What if a structure contains references or constants?

```cpp
// main.cc

struct MyStruct {
    const int myConst;
    int &myRef;
};

int main() {
    MyStruct p;
}

// This will not work because we can't have constants and references not initialized.
```

:arrow_heading_up: Doesn't work, constants and references are not initialized.



```cpp
int z;

struct MyStruct {
    const int myConst = 5;
    int &myRef = z;
};

// This works, but all my struct objects have the same reference and the same constant.
```



How do we initialize them so they are different?

```cpp
struct Student {
    const int studentID;
    ...
};
// we want each student have different ids, but we don't want them to change once we initialized the object
```

Where do we initialize? Constructor body? **No**, we can't, anything in the constructor body is an assignment because the fields already exist. The data fields in a constructor body are already been created (and initialized).

Constants *have* to be initialized when their space is allocated.

How can we do it before the constructor body runs?

What happens when an object is constructed?

1. space is allocated (on heap or on stack) 		
2. jfields are constructed            <-- MIL
3. constructor body runs



### Member Initialization Lists (MIL)

We need to inject our initializations into step 2. This can be achieved by using the **member initialization list** (**MIL**).

```cpp
struct Student {
    const int id;
    int assns, mt, final;
    // write our constructor
    Student(int id, int assns, int mt, int final) : 
    	id{id}, assns{assns}, mt{mt}, final{final} {}	// ctor body, which is empty
    // field_name { how_to_initialize }
}
```

The member initialization list code must be placed as part of the constructor implementation. It occurs between the closing parenthesis of the parameter list, and the opening curly braces of the constructor body.

It consists of a colon `:` followed by a comma-separated list of data field names to be initialized, where each data field is initialized using *uniform initialization syntax*.

**Notes**: 

- You can (and should) initialize any field in the MIL, not just constants or references

- Fields listed in the MIL are initialized in the order in which they are declared in the class, even if the MIL orders them differently

- the name *outside* of the `{}` in the MIL is the data fields, while the name *inside* of the `{}` is the parameter name.

- Using the MIL can be more efficient than assigning in the body of the constructor. 

  This is particularly true when the data field is an object that has a default constructor. ↓

- For fields that are objects, if they are not listed in the MIL, then they are default constructed (first initialized with the default constructor when it is created, and then initialized again in the body of the constructor using the assignment operator); if we then assign them in the constructor body, we wasted time default constructing them

  ```cpp
  struct Student {
      string name;
      Student(const string &name) {
          this->name = name;
      }
  };
  ```

  The data field "name" is initialized with the `std::string` default constructor, and then reassigned in the constructor body

- Embrace the MIL!

  



What if a fields is initialized in both the MIL and class definition?

```cpp
struct Vec {
    int x = 0, y = 0;	// initialization in the class definition
    Vec() {}
    Vec(int x) : x{x} {}	// initialization in the MIL
    Vec(int x, int y) : x{x}, y{y} {}
};
```

In this case, the initialization in the MIL takes *precedence*.

If we declare a vector `Vec v{5}`, the data fields x will contain the value 5, but the data field y will contain the value 0.

Note that we also have to explicitly overload the constructors to allow for all three possible ways of initializing the vector object.

However, that the MIL can only be used on constructors, not on any other method!

Note:

- It is quite common for constructors to have a MIL and an empty ctor body, and it's poor practice to use the body to do anything that the MIL could have done.
- rule of thumb: if you need sophisticated logic, such as loops or conditions to initialize your fields, use the ctor body, otherwise use the MIL!



## Copy Constructor

Now, consider:

```cpp
Student Max{60, 70, 80};
Student Evan = Max;
```

How is Evan initialized? -- via the **copy constructor**, which is invoked when one object is initialized with another of the same type.

**Note**: every class comes with compiler provided versions of:

- a default constructor (default-constructs all fields which are objects, lost when we define any ctor)
- a copy constructor (just copies all fields)
- a copy assignment operator (copy-assigns all fields)
- a move constructor
- a move assignment operator
- a destructor



A **copy constructor** is a constructor, so its signature must not return anything, and the name of the method must be the class name. Its only parameter will be a constant reference to an object of *the same type*.



To build your own copy constructor:

```cpp
struct Student {
    int assns, mt, final;
    // this is exact the same as the compiler provided version
    // the parameter must be a constant reference
    Student(const Student &other) :
    	assns{other.assns}, mt{other.mt}, final{other.final} {}	// don't copy the student id
};
```

For a vector, we want to copy every data field:

```cpp
struct Vec {
    int x, y;
    Vec(int x = 0, int y = 0) : x{x}, y{y} {} // ctor
    Vec(const Vec &other) : x{other.x}, y{other.y} {} // copy ctor
};
```

The copy ctor above is equivalent to the compiler provided version (the copy ctor that comes by default). When is this compiler provided version not enough?

Consider a linked list of nodes:

```cpp
struct Node {
    int data;
    Node *next;
    Node(int data, Node *next) : data{data}, next{next} {}
};

// if we use the compiler provided copy ctor
Node *n = new Node{1, new Node{2, new Node{3, nullptr}}};

Node m = *n; // copy ctor; identical to "Node m{*n}"
Node *p = new Node{*n}; // copy ctor
```

The problem:

![4-1](https://github.com/kila097/CS246_Notes/blob/main/images/4-1.jpg)

Note that n, m, and p are on the stack. The data they point to is on the heap (or in the case of m, the data its next ptr points at).

The built-in copy ctor does a **shallow copy**, it just copies the fields, meaning the pointer for next is copied, and the nodes share that pointer. (It just copied the existing addresses).

If we want a **deep copy**, we must write our own copy constructor.

Moral of the story: If you have a dynamically-allocated data structure and want a deep copy, write your own copy constructor.

```cpp
struct Node {
    int data;
    Node *next;
    Node(const Node &other) : data{other.data}, next{new Node{*other.next}} {}
    // invoke the copy ctor itself to make a new node
    // this is not done! we don't have base case
    // if other.next is the nullptr, we can't dereference the nullptr and will crash
};
```

We need to add that base case, to check if other.next is the nullptr:

```cpp
struct Node {
    int data;
    Node *next;
    Node(const Node &other) : data{other.data}, 
    	next{other.next ? new Node{*other.next} : nullptr} {} // other.next checks if it is a nullptr
}
```

When is our copy ctor called?

- when an object is initialized by another object
- when an object is passed in a function by value
- when an object is returned by a function by value

This is true, for now, we'll see exceptions for all three of these/



### The Peril of single-argument constructors

**Note**: be careful with constructors with one parameter.

```cpp
struct Node {
    int data;
    Node *next;
    Node(int data) : data{data}, next{nullptr} {}
};
```

Single argument constructors create implicit conversions.

```cpp
Node n{4}; // ok, calls ctor as expected (single-argument ctor call)
Node n = 4; // also calls the ctor, but is an implicit conversion from an int
```

A more dangerous version:

```cpp
int f(Node n) { ... }

f(4); // works! 4 got implicity converted to a Node
```

There is a high chance that this was a typo and we didn't actually mean to call this function on an integer. But, the compiler silently converts types because it can. In case this was an error, we would rather be  make aware of it.

Generally, it is a good idea to disallow compiler from using single parameter constructors as implicit conversions by marking them **`explicit`**.

```cpp
struct Node {
    ...
    explicit Node(int data) : data{data}, next{nullptr} {}
};

Node n{4}; // work!
Node n = 4; // error! no longer works

f(4); // error!
f(Node{4}); // work! we need to be explicit that we are converting that int to a Node
```

Example:

```cpp
struct Node {
  int data;
  Node *next = nullptr;
  explicit Node(int data) : data{data} {}
  Node(int data, Node *next): data{data}, next{next} {}

  Node(const Node &n): data{n.data},
                       next{n.next ? new Node{*n.next} : nullptr} {}
};


// If you try to create a node using implicit conversion, the compiler will produce an error
Node myNode = 4;
// the proper way is to create like this:
Node myNode = Node{4};
```





Now... the very very important subject

## Destructor

When an object is destroyed (which for stack allocated objects is when they go out of scope, and for heap allocated objects is when they are deleted), a method called the **destructor** runs.

Specifically, the following sequence of operations happens:

1. the destructor body runs
2. the destructors are invoked for all fields that are objects (happens in reverse declaration order)
3. space is deallocated



The signature for a class destructor follows the format:

```cpp
~class-name();
```

It takes no parameter and returns nothing. Dtors help your program to avoid memory leaks.



All classes come with a dtor (which just invokes dtors for all fields with are objects). When do we need to write our own?

```cpp
Node *np = next Node{1, new Node{2, new Node{3, nullptr}}};
```

If np goes out of scope, the pointer is reclaimed, as it is stack allocated, but the nodes it points at are not, so they are leaked!

If we say `delete np;`, then the first node is deleted, but all the remaining nodes are leaked, since delete was only ever called on the node np pointed at. If we want to ensure that the whole list is freed, we write a destructor.

```cpp
// node.h

#ifndef NODE_H
#define NODE_H

struct Node {
    int data;
    Node *next;
    Node(int data, Node *next) : data(data), next{next} {}
    Node(const Node &other) : data{other.data},
    	next{other.next ? new Node{*other.next} : nullptr} {}
    explicit Node(int data) : data(data), next{nullptr} {}
    // the destructor
    ~Node() {
        delete next;	// the data structure is recursive
    }
};


#endif
```

Now, `delete np;` frees the whole list.

We can also write:

```cpp
// node.h
#ifndef _NODE_H_
#define _NODE_H
#include <iostream>

struct Node {
    int data;
    Node *next;
    Node(int data, Node *next);
    Node(const Node &n);
    explicit Node(int n);
    ~Node();
};

std::ostream &operator<<(std::ostream &out, const Node &n);
#endif

// node.cc
#include "node.h"

Node::Node(int data, Node *next) : data{data}, next{next} {}

Node::Node(const Node &n) : data{n.data}, next{n.next ? new Node{*n.next} : nullptr} {}

Node::Node(int n) : data{n}, next{nullptr} {}

Node::~Node() {
    delete next;
}

std::ostream &operator<<(std::ostream &out, const Node &n) {
    out << n.data;
    if (n.next) {
        out << "," << *n.next;
    }
    return out;
}
```





## Copy Assignment Operator

The copy assignment opeartor= takes a constant reference of the class type as its single parameter (the object on the right-hand side of the assignment) and returns a reference of this class type.

The general signature format is:

```cpp
class-type & operator=( const class-type & parameter-name );
```



```cpp
Student a{60, 70, 80};
Student b = a; // copy ctor
Student c; // default ctor

c = b; // copy, but not a construction, c already exists!
// this is the copy assignment operator
```

Classes come with a **copy assignment operator (CAO)** that copy assigns all fields. This is a *shallow copy*.

Is this ok for our Student class? -- Yes!

```cpp
struct Student {
    int assns, mt, final;
 	...
};
```

But, a shallow copy is not always sufficient.





Consider our Node class：

```cpp
struct Node {
    int data;
    Node *next;
    ...
    Node &operator=(Node &other) {
        // NOTE, the first operand is the node pointed to by the this ptr
        data = other.data;
        next = other.next ? new Node{*other.next} : nullptr;
        return *this;
    }
    // this is NOT a construction, which means our fields already exists!
};

Node *np = new Node{1, new Node{2, new Node{3, nullptr}}};
Node *z = new Node{4, new Node{5, new Node{6, nullptr}}};
```
We now introduced a memory leak here:
![2](https://github.com/kila097/CS246_Notes/blob/main/images/4-2.jpg)

```cpp
Node & operator=(const Node &other) {
    data = other.data;
    delete next;
    next = other.next ? new Node{*other.next} : nullptr;
    return *this;
}
```

This sometimes works, but not always

```cpp
Node m{4, new Node{5, new Node{6, nullptr}}};
// What if we do:
m = m;

// or we could end up with two pointers to the same Node
Node *p1, *p2;
...
*p1 = *p2;
// we've just freed the list that both p2 and p1 point to before we attenpt the deep copy
```

Whoops! We deleted our own memory, and then tried to copy it. This problem is called **self-assignment**, and we can fix things by introducing a check for it.

```cpp
Node &operator=(const Node &other) {
    if (this == &other) return *this;	// compare memory address to see if they are the same
    data = other.data;
    delete next;
   	next = other.next ? new Node{*other.next} : nullptr;
    return *this;
}
```

We can improve the situation by changing the order of actions

```cpp
Node &operator=(const Node &other) {
    if (this == &other) return *this;
    Node *tmp = other.next? new Node{*other.next} : nullptr;
    data = other.data;
    delete next;
    next = tmp;
    return *this;
}
```

We make a deep copy of the linked list, our current node pointed to by `this` will contain the "head" information of other, the head of the new list is stored in a temporary pointer.

If the heap allocation fails, and the function terminates, our original node's data fields haven't been changed. Only if we've successfully completed the deep copy will free the old list that `next` points to, before overwriting it with the address in `tmp`

**Warning**: DON'T delete the address in tmp! This will destroy the copy of the list that you've just created.



### Copy-swap idiom

Alternative approach: use the **copy-and-swap idiom**. The approach relies upon the fact that a locally created object to the copy-assignment operator will be automatically destroyed when the object goes out of scope upon the routine's terminal. So, use the local object to make the deep copy, and if that was performed successfully, just swap the data of `this` and the local object.

```cpp
#include <utility>
struct Node {
    ...
    void swap(Node &other) {
        std::swap(data, other.data);
        std::swap(next, other.next);
    }
    
    Node &operator=(const Node &other) {
        Node temp{other};
        swap(tmp);
        return *this;
    }
    ...
};
```

By the end of tmp's initialization, it contains a deep copy of `other`. Then, exchange the contents of `this` and `tmp` using `Node::swap`. This way, `tmp.next` ends up with the old value of `this->next`, which is freed when `tmp` goes out of scope and its destructor is run.





## Move semantics (Feb 08)

Recall: **lvalues** and **rvalues**

If you can take the address of an expression, it is an lvalue; otherwise, it's an rvalue. Think of somthing that can appear on the left-hand side of an assignment statement.



Recall: int && x= ... ; // can't declare a reference to a reference ...

this is an r-value reference

Recall:

- A l-value is anything with an address
- A l-value reference (&) is like a const ptr with auto-dereferencing. Always must be initialized to an Ivalue.

If you declare as a const, you can use a number as a reference.



New consider:

plusOne takes a Node by value, and returns a Node by value. We transverse the singly-linked list and increment the data field by 1, then return a copy of the Node.

```cpp
Node plusOne(Node n) {
    for (Node *p = &n, p, p = p->next) {
        ++ p->data
    }
    return n;
}

int main() {
    Node n{1, new Node{2}};
    Node n2{plusOne(n)};
    std::cout << n << std::endl << n2 << std::endl;
}
```

The key concept here is that the initialization of n2 invokes a copy constructor to copy the contents of plusOne's parameter, n. The return of the function plusOne is an rvalue; however, Node's copy constructor expects to receive an lvalue reference. Thus, the compiler creates a temporary object to hold the result of plusOne. `other` is an reference to this temporary object and the copy ctor deep-copies from it. This object will be automatically discarded once the call to plusOne and Node's copy constructor ends.



We have to be able to tell whether or not the parameter other is a reference to a temporary object or is instead a stand-alone object. This is done in C++ by specifying that our temporary Node object is an *rvalue reference* to a Node. The syntax for this is `Node &&`. The operations that take an *rvalue reference* as the parameter are similar to copy operations, but are called **move** operations because they move the data from the temporary object to the object being initialized or assigned, instead of making a copy.



## Move constructor

A **move constructor** is designed to steal the information from the rvalue passed into the constructor. 

In general, the signature format will be:

```cpp
class-type ( class-type && parameter-name ) {...}
```

We are creating a brand-new object and thus don't need to worry about previous data field values. All we need to do is copy over the information from the rvalue; however, we need to be careful about any *shared* information we might have copied over that would be destroyed by the automatic invocation of the object's destructor!

In our implementation of the Node move ctor, we have to reset the pointer to the singlt-linked list in `other` (whose address we've copied) to `nullptr`; otherwise, the list that we've just stolen will be destroyed when this rvalue is destroyed.

The move constructor becomes:

```cpp
struct Node {
    ...
    Node( Node && other );
    ~Node();
    static void printNumCtorCalls();
};

...
    
Node::Node( Node && other ) : data{other.data}, next{other.next} {
    other.next = nullptr;
}

int Node::numCtorCalls = 0; Node::numCpyCtorCalls = 0; Node::numMoveCtorCalls = 0;

Node::Node(int data, Node *next) : data{data}, next{next} {
    numCtorCalls++:
}

Node::Node(const Node &other) : data{other.data},
	next{other.next ? new Node{*other.next} : nullptr} 
{
        numCpyCtorCalls++;
}

Node::Node(Node &&other) : data{other.data}, next{other.next} {
    other.next = nullptr;
    numMoveCtorCalls++;
}
```

Now when we write the following code fragment, the move constructor is run twice:

```cpp
Node plusOne( Node n ) {
    for ( Node *p{&n}; p; p = p->next ) {
        ++p->data;
    }
    return n;
}

int main() {
    Node n{ 1, new Node{2} };
    Node n2{ plusOne(n) };
    std::cout << n << std::endl << n2 << std::endl;
    Node::printNumCtorCalls();
}

void Node::printNumCtorCalls() {
    std::cout << numCtorCalls << "basic ctor calls\n" << numCpyCtorCalls << "copy ctor calls\n" << numMoveCtorCalls << "move ctor calls" << std:endl;
}
```



The move constructor runs twice:

1. once to take the information being returned from n in the return statement into a location in the run-time stack as an rvalue since plusOne returns a Node by value, and
2. once to move the information from the rvalue into n2



## Move assignment operator

**Move assignment** is structurally similar to copy assignment. We need to worry about self-assignment, and we need to make sure that we don't leak memory.

We are just now adding to our previous solution the fact that we can just steal the information directly from the rvalue rather than copying it. Since we know the rvalue is going to be destroyed soon, we can just exchange our old information with the new information from the rvalue, guaranteeing that it'll be properly cleaned up when the rvalue's destructor is run.

```cpp
struct Node {
    ...
    Node &operator=(Node &&other);
    void swap(Node &other);
    ...
};

...

Node &Node::operator=( Node &&other ) {
    swap(other);
    return *this;
}

void Node::swap(Node &other) {
    std::swap(data, other.data);
    std::swap(next, other.next);
}

// example of use
int main() {
    Node n2{...};
    n2 = plusOne(n2);
}
```



node.cc

```cpp
#include <iostream>
#include <utility>
using namespace std;

struct Node {
    int data;
    Node *next;
    Node(int data, Node *next) : data{data}, next{next} {}
	Node(const Node& other) : data{data}, next{other.next ? new Node{*other.next} \
        : nullptr} {
        cout << "Copy ctor called" << endl;
    }
    ~Node() { delete next; }
    
    void swap(Node &other) {
        std::swap(data, other.data);
        std::swap(next, other.next);
    }
    Node &operator=(const Node &other) {
        Node tmp{others};
        swap(tmp);
        cout << "CAO called" << endl;
        return *this;
    }
    Node(Node &&other) : data(other.data), next{other.next} {
        cout << "move ctor" << endl;
        other.next = nullptr;
    }
    Node &operator=(Node &&other) {
        swap(other);
        cout << "MAO called" << endl;
        return *this;
    }
};

Node plusOne(Node g) {
    for (Nide *p=&g; p; p=p->next) {
        ++p->data;
    }
    return g;
}

void printNode(Node &n) {
    for (Node *p=n; p; =p->next) {
        cout << p->data << "->"
    }
    cout << endl;
}

int main() {
    Node n{1, new Node{2, new Node{3, nullptr}}};
    Node n2 = plusOne(n); // copy ctor takes a const Node &other
    // &other is a l-value, it is allowed to be on the right side because it is const
    // the compiler creates a temporary location to hold the tmp object plusOne(n), so other has something to point to
    // temp object is destroyed once the construction is done
    Node m{1, nullptr};
    n = n2 = m = plusOne(n2);
    cout << "n: "; printNode(n);
    cout << "n2: "; printNode(n2);
    cout << "m: "; printNode(m);
}
```



So, the copy constructor is called 3 (non-recursive) times. 

- once to copy n into the parameter g
- once to copy g out of the function onto main's stack frame, as "the return value of plusOne"
- once to copy from the "return value of plusOne" into n2



BUT! g goes out of scope as soon plusOne returns, so why go through the effort of deep copying this potentially large list if it is just going to be destroyed anyways?

 Also... what is going to happen to the object "the return value of plusOne" - so it must be destroyed, otherwise we leak,  its lifetime is  0 until the end of this statement, this is what a temporary object is... this is an r-value.



## Copy/Move Elision (Feb 09)

return value plusOne(n2): 1

m: 3->4->5

n2: 2->3->4

n:1->2->3

n = n2 = (m = plusOne(n2));

n = n2 = (return value of m=plusOne(n2))

BECAUSE MAO returns an lvalue reference, now the CAO is called

n = (return value of n2 =...)



Consider:

```cpp
#include <iostream>

struct Node {
    static int numCtorCalls, numCpyCtorCalls;
    int data;
    Node *next;
    
    Node(int data, Node *next = nullptr);
    Node(const Node &other);
    ~Node() { delete next; }
    static void printNumCtorCalls();
};

std::ostream &operator<<(std::ostream &out, const Node &n);

Node plusOne(Node n) {
    for (Node *p{&n}; p; p = p->next) {
        ++p->data;
    }
    return n;
}

int main() {
    Node n{1, new Node{2}};
    Node n2{plusOne(n)};
    std::cout << n << std::endl << n2 << std::endl;
    Node::printNumCtorCalls();
}

// implementations follow
```

Recall: mentioned earlier that our constructors won't always take effects

`n2 = plusOne(n);`

What runs? move ctor? copy ctor? Maybe even just the basic ctor?



How many constructor calls should we see if we run this program?

1. In `main`'s first line. we first initialize a Node in the heap (1 regular ctor call)
2. Also in `main`'s first line, we initialize Node n in the stack (1 regular ctor call)
3. In `main`'s second line, invoke `plusOne` passing a copy of n as the parameter, to initialize `plusOne`'s parameter n, the copy ctor is invoked (1 copy constructor call)
4. The body of the copy ctor makes a deep copy, this means that it needs to make a copy of the heap-allocated Node pointed by next (1 copy ctor call)
5. the last line of `plusOne` returns the parameter n by value, this means that a copy of n must be made to be returned. Thus, the copy constructor is called again (1 copy ctor call)
6. Again, within the body of copy ctor, a deep copy of the Node pointed by next must be made (1 copy ctor call)
7. back to the second line of `main`. Now need to initialize n2 with an invocation to Node's copy ctor because we're passing the return of `plusOne` as the parameter to n2's initialization. So, the overloaded version of the ctor that received a Node reference is called (1 copy ctor call)
8. Once more, within the body of copy ctor, a deep copy of the Node pointed by next must be made (1 copy ctor call)

Therefore, we would expect to see **8** calls, 2 calls to regular ctor and 6 calls to the copy ctor

However, when we compile it:

```bash
$ g++ -std=c++14 -o node node.cc
$ ./node
1 2
2 3
2 basic ctor calls
4 copy ctor calls
```

We see that there are onley 4 invocations of the copy ctor instead of 6. 

Why did this happen? It turns out that the compiler can carry out an optimization called **elision**. (we are eliding/removing constructor calls). The compiler removes the ones where we would be copying/moving into from an rvalue. Since an rvalue has no accessible address, it is a temporary object designed to be thrown away, so the information may as well be written directly into the final destination.



Consider

`vec v = makeAVec();`

We may not copy or move at all!

In some circumstances, the compiler is allowed (but not required) to skip calling a copy/move ctor and instead opt to build the return value in place where it is going to be assigned.

What is means is:

`MakeAVec` writes its return value directly to the memory of V on the caller's stack frame.

It does so rather than creating a local copy then copying /moving it out to the caller's stack frame.

Consider:

```cpp
void doSomething(vec v) {	// pass by value // copy/move ctor
    ...
}

doSomething(makeAVec()); // would normally call move ctor (large is a temporary)
```



However, again the compiler can write the result of makeAvec directly to doSomething's parameter

This is called **move/copy** (depending on which one it is skipping) **elision**.



Copy elision is allowed even if the ctor calls would change the behaviour ot the program (e.g., printing something, modifying global variables, or any other side effects)

You are not expected to know when copy elision can occur, just need to know it may happen.

If you really don't want the compiler to omit such constructor calls, you can compile with the `-fno -lide-constructors` flag. But, this can slow your program significantly.



## Rules for replacing default compiler operators

| Member Function     | Implicitly Defined                                           | Default Definition |
| ------------------- | ------------------------------------------------------------ | ------------------ |
| Default Constructor | if no other constructors                                     | does nothing       |
| Destructor          | if no destructor                                             | does nothing       |
| Copy Constructor    | if no move constructor and no move assignment                | copies all members |
| Copy Assignment     | if no move constructor and no move assignment                | copies all members |
| Move Constructor    | if no destructor, no copy constructor and no copy nor move assignment | moves all members  |
| Move Assignment     | if no destructor, no copy constructor and no copy nor move assignment | moves all memvers  |



**Note**: If you don't define a move constructor/move assignment operator, then the copying versions of these operators will be used instead. If they are defined, then they will replace all calls to the copy versions when the argument is an rvalue (a temporary value).



## Rule of Five

In summary, we have:

1. Copy constructor
2. Copy Assignment operator
3. Destructor
4. Move constructor
5. Move assignment operator

They are all given to us as compiler provided (built-in) versions of them. Copy initializes each member. 

- In general, if Class manages a resource (e.g. memory, file pointer, network socket, etc.)

  You need these 5.

- In general, if you need one of these, you probably need all 5.

This is called the *rule of 5*, we refer to them as the **Big five**.





## Member operators

Some functions *must* be declared members of the class, others are not allowed to be class members.



Notice that operators was a member function, and not a standalone function. When an operator is declared as a member function, it's first operand is implicitly the object pointed at by `this`. This tells us that the object on which we are invoking the operation **must** be the left-hand-side operand to the operator

```cpp
struct Vec {
    int x, y;
   ...
    vec operator+(const Vec &other) {
       return {x + other.x, y + other.y};
   }
    vec operator*(int k) {
        return {x*k, y*k};
    }
};
```
Then we are implying that a Vec object *must* appear on the left of any multiplication operator:
```cpp
Vec v{1, 2};
Vec w{3, 4};
v = v + w; // ok
v = v * h; // ok
v = 3 * v; // can't do! Doesn't match the parameters
```

If we want to be able to do this, we must implement this version as *a stand alone* function. Otherwise, there is no way to have the `int` be the first operand (since int is not a class).

Hence, we move this version of `operator*` outside of Vec:

```cpp
struct Vec {
    
};

Vec operator*(int k, const vec &v) {
    return v * k;
}
```



What about our I/O operators?

```cpp
struct Vec {
    ...
    ostream & operator<<(ostream &out) {
        return out << x << ", " << y;
    }
};
```

What's wrong with this?

By definition, the class type has to be on the RHS of the operator since we expect the stream to be on the LHS; otherwise, this goes against the usual way we use the operators! Therefore, all of the I/O operators must be declared outside of the class.

`vec` is the LHS operand, to use this, we'd have to write code like: `v << cout`, which is confusing.

So naturally, `operator<<` and `opeator>>` should be standalone functions.



In summary;

Some operators **MUST** be member functions, as per the C++ standard:

- constructors
- destructor

- operator=
- operator[ ] (the index operator)
- operator-> (the points to operator)
- operator( ) (call your objects like a function/overloads the function call operator)
- operator T (where T is some type) (the conversion/casting operator to cast the object to the type T)



Some operators MUST NOT be member functions:

- operators whose first parameter isn't an object of the class type
- I/O operators, operator<< and operator>>



If the function doesn't fall into one of these two categories, then the choice is up to you.





## Static Members (Feb 15)

Sometimes we need to keep state or data across all objects of a class instead of for each individual object. (information belonging to the class)



The numMethodCalls field doesn't exactly do what I wanted it to, it only counts method calls individually for each object - Useless, unless I can go through every object created in my program and read that field. Not very feasible.

What if we want this field to track for the entire class? What if we want to track how many student objects are created?

**Static members** are associated with the class itself, **not** an individual object (instance) of the class.

```cpp
// student.h
Struct Student {
    static int numInstances;
    Student (int assns, int mt, int final) : assns{assns}, mt{mt}, final{final} {++numObjects;}
    
};

// student.cc
// you need to initialize it by specifying
int Student::numInstances = 0; // specify the namespace Student::
//   ↑ this is in the .cc file
```

As shown above, static must be initialized **external** of the class. At this point, the memory will be allocated for a single copy of the Student::numInstances field. This memory will be freed automatically when the program is terminated. It shouldn't be freed as part of the object destruction since it is not part of the object instantiation.



**Static members** (including functions) don't depend on specify instances of objects for their computation.

(they don't have an inplicit `this` parameter)

Thus, they can only access static fields and call other static memeber functions / methods.

```cpp
// student.h
Struct Student {
    ...
    static int numInstances;
    ...
    static void howMany(ostream &out) {
        out << numInstances << endl;
        // trying to access mt, final, or assns is illegal
        // same with trying to call grade()
    }
};
```

```cpp
// examples of (in main.cc)
Student Billy{60, 70, 80}, Student Moe{70, 90, 92};
Billy.howMany(cout);
Student::howMany(cout);  // the method is called on Student class
```







# 4.3 Advanced Object Uses



## Arrays of Objects

```cpp
struct Vec {
    int x, y;
    vec(int x, int y) : x{x}, y{y}, {}
};

Vec *vp = new vec[10]; // error! won't compile
Vec moreVectors[15]; // also error
```

These are errors because C++ must initialize these objects, but no default constructors exist!

Options?

1. provide a default ctor

   ```cpp
   struct Vec {
       int x, y;
       Vec( int x = 0, int y = 0 );
   };
   ```

2. For stack-arrays, provide the values:
	```cpp
	vec moreVectors[3] = {{1, 2}, {3, 4}, {5, 6}};
	```
	
3. For heap arrays, use an array of object *pointers* (pointers don't have to be initialized). Each element of the array must also be freed.

   ```cpp
   vec & vp = new vec x[10];
   vp(0) = new Vec{1, 2}
   ```
   ```cpp
	for (int i = 0; i < s; ++i) {
		delete vp[i]; // v[i] must be a valid memory address or nullptr
	}
	delete []vp;
	```




   ```cpp
   // objarray1.cc
   int size;
   Vec *arr[size];
   for (int i = 0; i < size; i++) {
       arr[i] = new Vec{i, i+1};
   }
   for (int i = 0; i < size; i++) {
       delete arr[i];
   }
   
   
   // objarray2.cc (for large array)
   int size;
   
   Vec **arr;
   arr = new Vec*[size];
   for (int i = 0; i < size; i++) {
       arr[i] = new Vec{i, i+1};
   }
   for (int i = 0; i < size; i++) {
       delete arr[i];
   }
   delete []arr;
   ```

   





## Constant Objects

A **constant object** is an object whose fields cannot be modified. 

```cpp
Student s{60, 70, 80}; // regular - non const objects (fields can be modified)
const Student s2 = s;  // fields of s2 cannot be modified (s can still be modified)
const Student s3{50, 75, 90}; // s3 is a const object (fields cannot be modified)

int f(const Node &n); // n cannot be modified inside f(), even if the object was not originally created as const
```

Constant objects arise often, often as parameters



Can we call methods on const objects?

```cpp
const Node n{...};
	n.fn();	// Can we say this?
```

Answer: *Yes*, we can call methods that don't modify the fields of the objects AND promise as such:

header:

```cpp
Struct Student {
    int assns, mt, final;
    float grade() const; // after the method name, declare it const, so it doesn't modify field 
    // anything that should be const, declare it as const
}
```

Implementation:

```cpp
float student::grade() const { // const is part of a function's signature, so must be included here
    return assns *0.4 + mt * 0.2 + final * 0.4;
}
```

Since we promised the compiler this method won't change anything (fields), the compiler will double check and produce an error if you do. 

*Only const methods may be called on const objects*.

### Mutable Fields

But.. perhaps we need to collect usage data on function calls. Even if those functions are called on const objects.

```cpp
Struct Student{
    int numMethodCalls = 0;
    float grade() const { // should this be const?
        ++ numMethodCalls;
        return ...;
    }
    
};
```

Now, grade can't be const because it mutates numMethodCalls, BUT we need to be able to call grade() on const objects.

On const objects, numMethodCalls doesn't change the **logical constness** (whether any change to the object is apparent to outsiders) of the object (everythign is means to be a student has remain unchanged), this only change the **physical constness** (whether the actual bit pattern that makes up the object changes).

So, we want to be able to change (to mutate) numMethodCalls in const functions, so we can declare numMethodCalls **mutable**.

```cpp
Struct Student {
    mutable int numMethodCalls; // mutable tells the compiler "it's okay to change this field in const methods"
    float grade() const {
        ++numMethodCalls; // this is OK now!
    }
}
```

Mutable fields can be changed, even if the object is const.

In general, don't use `mutable` too often, might start to make const meaningless.



### Best Practises

- Whenever you create a method that you know will not modify any internal fields of the object, declare the method as const. It will allow the method to be called on const objects.
- Whenever you create a method that receives objects as parameters and you know that the method will not modify those objects, mark the parameters as const. This will allow const objects to be passed as parameters
- If you have fields that must be modified even for const objects (such as numMethodCalls), declare the function as `mutable`. This will allow it to be modified even inside const methods
- Whenever you create (instantiate) a new object and you know that the value of the fields should not be modified anymore after initialization, declare it as a const object. This will prevent accidental modification in other parts of the code.
